{% macro filter() %}
<div id="filter-controls" class="d-none">
    <select id="category-filter" class="form-select">
        <option selected disabled>Select Categories</option>
    </select>
    <select id="tag-filter" class="form-select">
        <option selected>Select Tags</option>
    </select>
    <button class="btn btn-secondary text-nowrap" id="reset-filters">Reset Filters</button>
</div>

<div class="modal fade" id="noEventsModal" tabindex="-1" aria-labelledby="noEventsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h1 class="modal-title fs-5" id="noEventsModalLabel">No Events Found</h1>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>No upcoming events were found with the selected filters</p>
                <p>Would you like to search for past events instead?</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <a id="prvious-link" href="#" class="btn btn-primary text-white">Search Past Events</a>
            </div>
        </div>
    </div>
</div>
{% endmacro %}

{% macro filterjs() %}
<script>
document.addEventListener("DOMContentLoaded", () => {
    // allowed categories and their display names
    // (duplicated in /config.py)
    const ALLOWED_CATEGORIES = [
        "gaming", "academic", "social", "inclusivity", "tech", "other"
    ];
    const CATEGORY_NAMES = {
        "gaming": "Gaming",
        "academic": "Academic",
        "tech": "Tech",
        "social": "Social",
        "inclusivity": "Wildcards",
        "other": "Other"
    };

    const usedCategories = new Set(); // categories that have events
    const usedTags = new Set(); // tags that have events
    const tagCategories = new Map(); // map of tags to which categories they belong to

    function loadSingleEventData(event) {
        // categories can be loosly mapped to colours
        // assign to other if unknown
        let category = event.getAttribute("data-event-colour") || "other";
        if (!ALLOWED_CATEGORIES.includes(category)) {
            category = "other";
        }
        usedCategories.add(category);

        // get tags by splitting the data-event-tags attribute
        const tags = (event.getAttribute("data-event-tags") || "").split(",").map(t => t.trim()).filter(Boolean);
        for (const tag of tags) {
            // add tags to the used set
            // also add to the mapping
            usedTags.add(tag);
            if (!tagCategories.has(tag)) {
                tagCategories.set(tag, new Set());
            }
            tagCategories.get(tag).add(category);
        }

        return { elem: event, category, tags };
    }

    // get all page elements
    const eventsDiv = document.getElementById("events");
    const events = Array.from(eventsDiv.querySelectorAll("a.event")).map(loadSingleEventData);
    const categorySelect = document.getElementById("category-filter");
    const tagSelect = document.getElementById("tag-filter");
    const resetButton = document.getElementById("reset-filters");
    const filterControls = document.getElementById("filter-controls");

    console.log(usedCategories, usedTags)

    if (usedCategories.size > 0 || usedTags.size > 0) {
        // if things can be filtered, display the filter controls
        filterControls.classList.remove("d-none");
        filterControls.className = "d-flex align-items-center gap-2";
    }

    // create category options
    const sortedCategories = Array.from(usedCategories).sort((a, b) => {
        if (a === "other") return 1; // always put "other" at the end
        if (b === "other") return -1;
        return CATEGORY_NAMES[a].localeCompare(CATEGORY_NAMES[b]); // sort by display name alphabetically
    });
    for (const category of sortedCategories) {
        const option = document.createElement("option");
        option.value = category;
        option.textContent = CATEGORY_NAMES[category];
        categorySelect.appendChild(option);
    }

    // create tags
    for (const tag of Array.from(usedTags).sort()) {
        const option = document.createElement("option");
        option.value = tag;
        option.textContent = tag;
        tagSelect.appendChild(option);
    }

    // current state of filters
    let selectedCategory = null;
    let selectedTag = null;
    let enabledTags = new Set(usedTags); // tags that intersect with the selected category

    categorySelect.addEventListener("change", () => {
        // update selected category
        selectedCategory = categorySelect.value;
        updateAvailableTags(); // this will change the number of available tags
        updateEventView();
    });

    tagSelect.addEventListener("change", () => {
        selectedTag = tagSelect.value;
        updateEventView();
    });

    function updateAvailableTags() {
        enabledTags = new Set(); // tags that intersect with the selected category
        for (const tag of usedTags) {
            const categories = tagCategories.get(tag) || new Set();
            if (!selectedCategory || categories.has(selectedCategory)) {
                // enable a tag if it belongs to the selected category or if no category is selected
                enabledTags.add(tag);
            }
        }

        for (const option of tagSelect.options) {
            // toggle visibility if the tag is enabled or not
            option.classList.toggle("d-none", !enabledTags.has(option.value));
            if (!enabledTags.has(option.value) && option.selected) {
                option.selected = false;
                selectedTag = null;
            }
        }

        // remove tags select if no tags are available
        tagSelect.classList.toggle("d-none", enabledTags.size === 0);
    }

    function updateEventView() {
        for (const event of events) {
            // remove an event if it not a member of selected category or tag
            const matchesCategory = !selectedCategory || event.category === selectedCategory;
            const matchesTag = !selectedTag || event.tags.includes(selectedTag);
            const visible = matchesCategory && matchesTag;
            event.elem.classList.toggle("d-none", !visible);
        }

        // hide empty sections
        hideEmptyDays();
        hideEmptyWeeks();
        hideEmptyTerms();
        hideEmptyYears();
    }

    resetButton.addEventListener("click", () => {
        // reset filters
        categorySelect.selectedIndex = 0;
        tagSelect.selectedIndex = 0;
        selectedCategory = null;
        selectedTag = null;
        updateAvailableTags();
        updateEventView();
    });

    function isVisibleEventElem(event) {
        // check if an event is valid under the current tags (displayed)
        return event.matches("a.event") && !event.classList.contains("d-none");
    }

    function hasVisibleEventBetween(startNode, stopTags) {
        // check if there is a visible event between startNode and the next stop tag
        let node = startNode.nextElementSibling;
        while (node) {
            if (stopTags.has(node.tagName)) return false; // if reached a stop tag, no events
            if (isVisibleEventElem(node)) return true; // if reached a visible event, events
            node = node.nextElementSibling;
        }
        return false;
    }

    function hideEmptyDays() {
        const stopTags = new Set(["H4", "H3", "H2", "H1"]); // H1: year, H2: term, H3: week, H4: day
        for (const h of eventsDiv.querySelectorAll("h4")) {
            // if the day has no events associated, hide it
            h.classList.toggle("d-none", !hasVisibleEventBetween(h, stopTags));
        }
    }

    function hideEmptyWeeks() {
        const stopTags = new Set(["H3", "H2", "H1"]);
        for (const h of eventsDiv.querySelectorAll("h3")) {
            if (/Week\s+[-–−]?\d+/i.test(h.textContent)) { // regex to match negative weeks
                h.classList.toggle("d-none", !hasVisibleEventBetween(h, stopTags));
            }
        }
    }

    function hideEmptyTerms() {
        const stopTags = new Set(["H2", "H1"]);
        for (const h of eventsDiv.querySelectorAll("h2")) {
            h.classList.toggle("d-none", !hasVisibleEventBetween(h, stopTags));
        }
    }

    function hideEmptyYears() {
        const stopTags = new Set(["H1"]);
        for (const h of eventsDiv.querySelectorAll("h1")) {
            h.classList.toggle("d-none", !hasVisibleEventBetween(h, stopTags));
        }
    }

    // check query params for preselected filters
    const params = new URLSearchParams(window.location.search);

    // handle category
    const categoryParam = params.get("category");
    if (categoryParam && usedCategories.has(categoryParam)) {
        selectedCategory = categoryParam;
        categorySelect.value = categoryParam;
    }

    updateAvailableTags();

    // handle tag
    const tagParam = params.get("tag");
    if (tagParam && usedTags.has(tagParam)) {
        selectedTag = tagParam;
        tagSelect.value = tagParam;
    }

    // initially parse to hide stuff if necessary
    updateEventView();

    // if neither category nor tag gets event, show modal
    if (!(selectedCategory || selectedTag)) {
        const modalLink = document.getElementById("prvious-link");
        modalLink.href = "{{ url_for('previous') }}?" + params.toString();

        modal = new bootstrap.Modal(document.getElementById('noEventsModal'));
        modal.show();
    }
});
</script>
{% endmacro %}