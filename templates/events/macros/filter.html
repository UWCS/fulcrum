{% macro filter() %}
<div class="d-none" id="filter-controls">
    <span class="h4">Filter Events</span>
    <span id="category-filters" class="d-none"></span>
    <span id="tag-filters" class="d-none"></span>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    // import categories as the various colours
    const ALLOWED_CATEGORIES = [
        "gaming", "academic", "social", "inclusivity", "tech", "other"
    ];
    // each category has a colour, with a default for "other"
    const CATEGORY_COLOURS = {
        {% for name, colour in colours.items() %}
            "{{ name }}":"{{ colour }}",
        {% endfor %}
        "other":"{{ colours['secretary'] }}"
    };
    // display names
    const CATEGORY_NAMES = {
        "gaming": "Gaming",
        "academic": "Academic",
        "tech": "Tech",
        "social": "Social",
        "inclusivity": "Wildcards",
        "other": "Other"
    };

    const used_categories = new Set(); // categories in existence
    const used_tags = new Set(); // tags in existence
    const tag_categories = new Map(); // tag -> Set of categories that use this tag

    function load_single_event_data(elem) {
        // get category by colour attribute (other if none)
        let category = elem.getAttribute("data-event-colour") || "";
        if (!ALLOWED_CATEGORIES.includes(category)) {
            category = "other";
        }
        used_categories.add(category);

        // get tags from tags attribute
        const data_tags_raw = elem.getAttribute("data-event-tags") || "";
        const tags = data_tags_raw === ""
            ? []
            : data_tags_raw.split(",").map(t => t.trim()).filter(Boolean);

        // add tags to used_tags and map
        for (const tag of tags) {
            if (!tag_categories.has(tag)) {
                tag_categories.set(tag, new Set());
            }
            used_tags.add(tag);
            tag_categories.get(tag).add(category);
        }

        return { elem, category, tags };
    }

    // load all events
    const event_holder = document.getElementById("events");
    const event_elms = event_holder.querySelectorAll("a.event");
    const events = Array.from(event_elms).map(load_single_event_data);

    // get filters
    const category_filter_holder = document.getElementById("category-filters");
    const tag_filter_holder = document.getElementById("tag-filters");

    // unhide filter if usable
    if (used_categories.size > 0 || used_tags.size > 0) {
        document.getElementById("filter-controls").classList.remove("d-none");
    }
    if (used_categories.size > 0) {
        category_filter_holder.classList.remove("d-none");
    }
    if (used_tags.size > 0) {
        tag_filter_holder.classList.remove("d-none");
    }

    // create category buttons
    for (const cat of Array.from(used_categories).sort()) {
        const b = document.createElement("button");
        b.innerText = CATEGORY_NAMES[cat];
        b.classList.add("btn", "event-tag", "m-1");
        b.style.setProperty("--highlight-colour", CATEGORY_COLOURS[cat] ?? CATEGORY_COLOURS.other);
        b.addEventListener("click", () => toggle_filter_category(cat));
        category_filter_holder.appendChild(b);
    }

    // create tag buttons
    for (const tag of Array.from(used_tags).sort()) {
        const b = document.createElement("button");
        b.innerText = tag;
        b.classList.add("btn", "event-tag", "m-1");
        b.addEventListener("click", () => toggle_filter_tag(tag));
        tag_filter_holder.appendChild(b);
    }

    // initial state: all categories selected, no tags selected, all tags can be selected
    const filter_categories = new Set();
    const selected_tags = new Set();
    let enabled_tags = new Set(used_tags);

    function toggle_filter_category(category_name) {
        // toggle visual state of a catefory
        for (const child of category_filter_holder.children) {
            if (child.innerText === CATEGORY_NAMES[category_name]) {
                if (filter_categories.has(category_name)) {
                    // remove from filter if selected
                    child.classList.remove("event-tag-selected");
                    filter_categories.delete(category_name);
                } else {
                    // add to filter if not selected
                    child.classList.add("event-tag-selected");
                    filter_categories.add(category_name);
                }
                break;
            }
        }

        // update tag visibility
        enabled_tags = new Set();
        for (const tag of used_tags) {
            const cats_for_tag = tag_categories.get(tag) || new Set();
            if (
                filter_categories.size === 0 ||
                intersect(cats_for_tag, filter_categories).size !== 0
            ) {
                // keep tag visible + enabled
                showTagButton(tag, true);
                enabled_tags.add(tag);
            } else {
                // hide tag if not selected or usable
                showTagButton(tag, false);
            }
        }

        // hide tag filter holder entirely if nothing left
        if (enabled_tags.size === 0) {
            tag_filter_holder.classList.add("d-none");
        } else {
            tag_filter_holder.classList.remove("d-none");
        }

        update_event_view();
    }

    function showTagButton(tag_name, show) {
        // show or hide a tag button
        for (const child of tag_filter_holder.children) {
            if (child.innerText === tag_name) {
                if (show) {
                    child.classList.remove("d-none");
                } else {
                    child.classList.add("d-none");
                    // also de-select if it was selected
                    child.classList.remove("event-tag-selected");
                    selected_tags.delete(tag_name);
                }
                break;
            }
        }
    }

    function toggle_filter_tag(tag_name) {
        // filter events by tag
        for (const child of tag_filter_holder.children) {
            if (child.innerText === tag_name) {
                if (selected_tags.has(tag_name)) {
                    // remove from selected tags if already selected
                    child.classList.remove("event-tag-selected");
                    selected_tags.delete(tag_name);
                } else {
                    // add to selected tags if not selected
                    child.classList.add("event-tag-selected");
                    selected_tags.add(tag_name);
                }
                break;
            }
        }
        update_event_view();
    }

    function update_event_view() {
        // find tags that can be shown
        const filter_tags = intersect(enabled_tags, selected_tags);

        // Show/hide events
        for (const event of events) {
            // event can be seen if it has a category selected
            let hide_cat = (filter_categories.size !== 0 && !filter_categories.has(event.category));

            // event can be seen if it has a tag selected
            let hide_tag = false;
            if (filter_tags.size > 0) {
                hide_tag = true;
                for (const t of event.tags) {
                    if (filter_tags.has(t)) {
                        hide_tag = false;
                        break;
                    }
                }
            }

            // hide if no category selected or no tag selected
            if (hide_cat || hide_tag) {
                event.elem.classList.add("d-none");
            } else {
                event.elem.classList.remove("d-none");
            }
        }

        // Update headings visibility
        hideEmptyDays();
        hideEmptyWeeks();
        hideEmptyTerms();
        hideEmptyYears();
    }

    function isVisibleEventElem(el) {
        // check if an event is visible
        return el.matches("a.event") && !el.classList.contains("d-none");
    }

    function hasVisibleEventBetween(startNode, stopTags) {
        // scan forward until next heading is reached or an event is found
        let node = startNode.nextElementSibling;
        while (node) {
            const tag = node.tagName;
            if (stopTags.has(tag)) return false;
            if (isVisibleEventElem(node)) return true;
            node = node.nextElementSibling;
        }
        return false;
    }

    function hideEmptyDays() {
        // hide all day headings that have no visible events
        const stopTags = new Set(["H4", "H3", "H2", "H1"]);
        for (const dayHeading of event_holder.querySelectorAll("h4")) {
            const hasVisible = hasVisibleEventBetween(dayHeading, stopTags);
            dayHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function hideEmptyWeeks() {
        // hide all week headings that have no visible events
        const stopTags = new Set(["H3", "H2", "H1"]);

        // funky regex for negative week numbers
        const weekRe = /Week\s+([-–−]?\d+)/i;

        for (const weekHeading of event_holder.querySelectorAll("h3")) {
            const txt = weekHeading.textContent;
            if (!weekRe.test(txt)) continue;

            const hasVisible = hasVisibleEventBetween(weekHeading, stopTags);
            weekHeading.classList.toggle("d-none", !hasVisible);
        }
    }


    function hideEmptyTerms() {
        // hide all term headings that have no visible events
        const stopTags = new Set(["H2", "H1"]);
        for (const termHeading of event_holder.querySelectorAll("h2")) {
            const hasVisible = hasVisibleEventBetween(termHeading, stopTags);
            termHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function hideEmptyYears() {
        // hide all year headings that have no visible events
        const stopTags = new Set(["H1"]);
        const years = event_holder.querySelectorAll("h1");
        for (const yearHeading of years) {
            const hasVisible = hasVisibleEventBetween(yearHeading, stopTags);
            yearHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function intersect(a, b) {
        const res = new Set();
        for (const v of a) {
            if (b.has(v)) res.add(v);
        }
        return res;
    }

    // initial pass to clean headings
    update_event_view();
});
</script>

{% endmacro %}