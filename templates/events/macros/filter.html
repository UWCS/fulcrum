{% macro filter() %}
<div id="filter-controls" class="d-none">
    <select id="category-filter" class="form-select">
        <option selected disabled>Select Categories</option>
    </select>
    <select id="tag-filter" class="form-select">
        <option selected>Select Tags</option>
    </select>
    <button class="btn btn-secondary text-nowrap" id="reset-filters">Reset Filters</button>
</div>
{% endmacro %}

{% macro filterjs() %}
<script>
document.addEventListener("DOMContentLoaded", () => {
    // import categories as the various colours
    const ALLOWED_CATEGORIES = [
        "gaming", "academic", "social", "inclusivity", "tech", "other"
    ];
    // each category has a colour, with a default for "other"
    const CATEGORY_COLOURS = {
        {% for name, colour in colours.items() %}
            "{{ name }}":"{{ colour }}",
        {% endfor %}
        "other":"{{ colours['secretary'] }}"
    };
    // display names
    const CATEGORY_NAMES = {
        "gaming": "Gaming",
        "academic": "Academic",
        "tech": "Tech",
        "social": "Social",
        "inclusivity": "Wildcards",
        "other": "Other"
    };

    const used_categories = new Set(); // categories in existence
    const used_tags = new Set(); // tags in existence
    const tag_categories = new Map(); // tag -> Set of categories that use this tag

    function load_single_event_data(elem) {
        // get category by colour attribute (other if none)
        let category = elem.getAttribute("data-event-colour") || "";
        if (!ALLOWED_CATEGORIES.includes(category)) {
            category = "other";
        }
        used_categories.add(category);

        // get tags from tags attribute
        const data_tags_raw = elem.getAttribute("data-event-tags") || "";
        const tags = data_tags_raw === ""
            ? []
            : data_tags_raw.split(",").map(t => t.trim()).filter(Boolean);

        // add tags to used_tags and map
        for (const tag of tags) {
            if (!tag_categories.has(tag)) {
                tag_categories.set(tag, new Set());
            }
            used_tags.add(tag);
            tag_categories.get(tag).add(category);
        }

        return { elem, category, tags };
    }

    // load all events
    const event_holder = document.getElementById("events");
    const event_elms = event_holder.querySelectorAll("a.event");
    const events = Array.from(event_elms).map(load_single_event_data);

    // get filters
    const category_filter_holder = document.getElementById("category-filter");
    const tag_filter_holder = document.getElementById("tag-filter");

    // unhide filter if usable
    if (used_categories.size > 0 || used_tags.size > 0) {
        const filter_controls = document.getElementById("filter-controls");
        filter_controls.classList.remove("d-none");
        filter_controls.classList = "d-flex align-items-center gap-2";
    }
    if (used_categories.size > 0) {
        category_filter_holder.classList.remove("d-none");
    }
    if (used_tags.size > 0) {
        tag_filter_holder.classList.remove("d-none");
    }

    // create category buttons
    for (const cat of Array.from(used_categories).sort()) {
        const opt = document.createElement("option");
        opt.value = cat;
        opt.textContent = CATEGORY_NAMES[cat];
        category_filter_holder.appendChild(opt);
    }

    // create tag buttons
    for (const tag of Array.from(used_tags).sort()) {
        const opt = document.createElement("option");
        opt.value = tag;
        opt.textContent = tag;
        tag_filter_holder.appendChild(opt);
    }

    // add event listene for category filter
    category_filter_holder.addEventListener("change", () => {
        filter_categories.clear();
        for (const option of category_filter_holder.selectedOptions) {
            filter_categories.add(option.value);
        }
        update_available_tags();
        update_event_view();
    });

    // add event listener for tag filter
    tag_filter_holder.addEventListener("change", () => {
        selected_tags.clear();
        for (const option of tag_filter_holder.selectedOptions) {
            selected_tags.add(option.value);
        }
        update_event_view();
    });

    // initial state: all categories selected, no tags selected, all tags can be selected
    const filter_categories = new Set();
    const selected_tags = new Set();
    let enabled_tags = new Set(used_tags);

    function showTagButton(tag_name, show) {
        // show or hide a tag button
        for (const child of tag_filter_holder.children) {
            if (child.innerText === tag_name) {
                if (show) {
                    child.classList.remove("d-none");
                } else {
                    child.classList.add("d-none");
                    // also de-select if it was selected
                    child.classList.remove("event-tag-selected");
                    selected_tags.delete(tag_name);
                }
                break;
            }
        }
    }

    // update available tags based on selected categories
    function update_available_tags() {
        enabled_tags = new Set();
        // attempt to ebable all used tags
        for (const tag of used_tags) {
            const cats_for_tag = tag_categories.get(tag) || new Set();
            if (filter_categories.size === 0 || intersect(filter_categories, cats_for_tag).size > 0) {
                enabled_tags.add(tag);
            }
        }

        // hide or show tag filtering options
        for (const opt of tag_filter_holder.options) {
            if (enabled_tags.has(opt.value)) {
                opt.classList.remove("d-none");
            } else {
                opt.classList.add("d-none");
                opt.selected = false;
                selected_tags.delete(opt.value);
            }
        }

        // update tag filter holder visibility
        tag_filter_holder.classList.toggle("d-none", enabled_tags.size === 0);
    }

    function update_event_view() {
        // find tags that can be shown
        const filter_tags = intersect(enabled_tags, selected_tags);

        // Show/hide events
        for (const event of events) {
            // event can be seen if it has a category selected
            let hide_cat = (filter_categories.size !== 0 && !filter_categories.has(event.category));

            // event can be seen if it has a tag selected
            let hide_tag = false;
            if (filter_tags.size > 0) {
                hide_tag = true;
                for (const t of event.tags) {
                    if (filter_tags.has(t)) {
                        hide_tag = false;
                        break;
                    }
                }
            }

            // hide if no category selected or no tag selected
            if (hide_cat || hide_tag) {
                event.elem.classList.add("d-none");
            } else {
                event.elem.classList.remove("d-none");
            }
        }

        // Update headings visibility
        hideEmptyDays();
        hideEmptyWeeks();
        hideEmptyTerms();
        hideEmptyYears();
    }

    function isVisibleEventElem(el) {
        // check if an event is visible
        return el.matches("a.event") && !el.classList.contains("d-none");
    }

    function hasVisibleEventBetween(startNode, stopTags) {
        // scan forward until next heading is reached or an event is found
        let node = startNode.nextElementSibling;
        while (node) {
            const tag = node.tagName;
            if (stopTags.has(tag)) return false;
            if (isVisibleEventElem(node)) return true;
            node = node.nextElementSibling;
        }
        return false;
    }

    function hideEmptyDays() {
        // hide all day headings that have no visible events
        const stopTags = new Set(["H4", "H3", "H2", "H1"]);
        for (const dayHeading of event_holder.querySelectorAll("h4")) {
            const hasVisible = hasVisibleEventBetween(dayHeading, stopTags);
            dayHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function hideEmptyWeeks() {
        // hide all week headings that have no visible events
        const stopTags = new Set(["H3", "H2", "H1"]);

        // funky regex for negative week numbers
        const weekRe = /Week\s+([-–−]?\d+)/i;

        for (const weekHeading of event_holder.querySelectorAll("h3")) {
            const txt = weekHeading.textContent;
            if (!weekRe.test(txt)) continue;

            const hasVisible = hasVisibleEventBetween(weekHeading, stopTags);
            weekHeading.classList.toggle("d-none", !hasVisible);
        }
    }


    function hideEmptyTerms() {
        // hide all term headings that have no visible events
        const stopTags = new Set(["H2", "H1"]);
        for (const termHeading of event_holder.querySelectorAll("h2")) {
            const hasVisible = hasVisibleEventBetween(termHeading, stopTags);
            termHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function hideEmptyYears() {
        // hide all year headings that have no visible events
        const stopTags = new Set(["H1"]);
        const years = event_holder.querySelectorAll("h1");
        for (const yearHeading of years) {
            const hasVisible = hasVisibleEventBetween(yearHeading, stopTags);
            yearHeading.classList.toggle("d-none", !hasVisible);
        }
    }

    function intersect(a, b) {
        const res = new Set();
        for (const v of a) {
            if (b.has(v)) res.add(v);
        }
        return res;
    }

    // reset filters button
    document.getElementById("reset-filters").addEventListener("click", () => {
        // reset all filters
        category_filter_holder.selectedIndex = 0; // deselect all categories
        tag_filter_holder.selectedIndex = 0; // deselect all tags

        // clear filter sets
        filter_categories.clear();
        selected_tags.clear();

        // update ui
        update_available_tags();
        update_event_view();
    });

    // initial pass to clean headings
    update_event_view();
    update_available_tags();
});
</script>
{% endmacro %}