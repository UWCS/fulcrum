import base64
import math
import random
import re
from collections import deque
from pathlib import Path

import svg
from svgpathtools import parse_path

from config import colours, icon_paths
from events.utils import get_events_in_week_range, group_events
from schema import Week

# params for sizing for everything
POST_HEIGHT, POST_WIDTH = 2028, 2028

# logo shennanigans
LOGO_SCALE = 0.35
LOGO_TRANSLATE_X = 1887
LOGO_TRANSLATE_Y = 198

# space dots can be in
DOTS_X, DOTS_Y = POST_WIDTH, 436

# size of blue background
BLUE_Y = 1914
BLUE_RX = 3002
BLUE_RY = 1566

# size for title (week or term)
TITLE_SIZE = 110

# max grid size for single week
MAX_GRID_COLS = 4
MAX_GRID_ROWS = 2

# spacing of days in single week
DAY_TEXT_HEIGHT = 125
DAY_TEXT_SIZE = 70
CIRCLE_SIZE = 400
CELL_PADDING = 0.9

# max weeks for multi week
MAX_WEEKS = 5


# this was entirely generated by chatgpt good look debugging :)
def poisson_disc_samples(
    width: float, height: float, radius: float, k: int
) -> list[tuple[float, float]]:
    """Poisson disc sampling using bridson's algorithm"""
    cell_size = radius / math.sqrt(2)
    grid_width = math.ceil(width / cell_size)
    grid_height = math.ceil(height / cell_size)

    grid = [[None for _ in range(grid_height)] for _ in range(grid_width)]
    points = []
    active = deque()

    first_point = (random.uniform(0, width), random.uniform(0, height))  # noqa: S311
    points.append(first_point)
    active.append(first_point)

    grid_x, grid_y = int(first_point[0] // cell_size), int(first_point[1] // cell_size)
    grid[grid_x][grid_y] = first_point  # type: ignore

    while active:
        idx = random.randrange(len(active))  # noqa: S311
        point = active[idx]
        found = False

        for _ in range(k):
            r = random.uniform(radius, 2 * radius)  # noqa: S311
            angle = random.uniform(0, 2 * math.pi)  # noqa: S311
            new_point = (point[0] + r * math.cos(angle), point[1] + r * math.sin(angle))

            if not (0 <= new_point[0] < width and 0 <= new_point[1] < height):
                continue

            grid_x, grid_y = int(new_point[0] // cell_size), int(
                new_point[1] // cell_size
            )
            too_close = False

            for i in range(max(0, grid_x - 2), min(grid_width, grid_x + 3)):
                for j in range(max(0, grid_y - 2), min(grid_height, grid_y + 3)):
                    neighbor = grid[i][j]
                    if neighbor and math.dist(new_point, neighbor) < radius:
                        too_close = True
                        break
                if too_close:
                    break

            if not too_close:
                points.append(new_point)
                active.append(new_point)
                grid[grid_x][grid_y] = new_point  # type: ignore
                found = True
                break

        if not found:
            active.remove(point)

    return points


def random_dots() -> list[svg.Element]:
    """generate random dots using poisson disc sampling"""

    # params
    radius = 13
    opacity = 0.4
    num = 30
    spacing = radius * 10
    k = 30  # limit of samples before rejection

    points = poisson_disc_samples(DOTS_X, DOTS_Y, spacing, k)

    if len(points) > num:
        points = random.sample(points, num)

    dot_colours = [colours["greyer"], colours["blue"], colours["yellow"]]

    dots = []
    for cx, cy in points:
        fill = random.choice(dot_colours)  # noqa: S311
        dots.append(
            svg.Circle(
                cx=cx,
                cy=cy,
                r=radius,
                fill=fill,
                opacity=opacity,
            )
        )
    return dots


def get_b64_font(path: str) -> str:
    """get base64 encoded font from path"""
    with Path(path).open("rb") as f:
        bytes = f.read()
    encoded = base64.b64encode(bytes).decode("utf-8")
    return f"data:font/ttf;base64,{encoded}"


def convert_path_to_list(
    path: str,
) -> tuple[list[svg.PathData], float, float, float, float]:
    """
    Converts an SVG path string to a list of svg.PathData object
    also returns width, height, min_x, min_y of the path
    """

    # regex to match commands and numbers
    num_regex = re.compile(r"[A-Za-z]|[+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]?\d+)?")

    def num(num: str) -> float | int:
        """convert string to int if possible, else float"""
        f = float(num)
        return int(f) if f.is_integer() else f

    # number of parameters for each command
    param_counts = {
        **dict.fromkeys("Zz", 0),
        **dict.fromkeys("HhVv", 1),
        **dict.fromkeys("MmLlTt", 2),
        **dict.fromkeys("SsQq", 4),
        **dict.fromkeys("Cc", 6),
        **dict.fromkeys("Aa", 7),
    }

    # map commands to svg.PathData classes
    command_map = {
        "M": svg.MoveTo,
        "m": svg.MoveToRel,
        "L": svg.LineTo,
        "l": svg.LineToRel,
        "H": svg.HorizontalLineTo,
        "h": svg.HorizontalLineToRel,
        "V": svg.VerticalLineTo,
        "v": svg.VerticalLineToRel,
        "C": svg.CubicBezier,
        "c": svg.CubicBezierRel,
        "S": svg.SmoothCubicBezier,
        "s": svg.SmoothCubicBezierRel,
        "Q": svg.QuadraticBezier,
        "q": svg.QuadraticBezierRel,
        "T": svg.SmoothQuadraticBezier,
        "t": svg.SmoothQuadraticBezierRel,
        "A": svg.Arc,
        "a": svg.ArcRel,
        "Z": svg.ClosePath,
        "z": svg.ClosePath,
    }

    tokens = num_regex.findall(path)  # tokenise the path string
    i, cmd = 0, None  # current command
    path_data = []  # list of svg.PathData objects

    while i < len(tokens):
        tok = tokens[i]
        if tok.isalpha():  # if token is a letter, its a command
            cmd, i = tok, i + 1
            if cmd in "Zz":
                # z indicates closing the path
                path_data.append(svg.ClosePath())
                continue

        # no command
        if cmd is None:
            raise ValueError("invalid path data")

        # get number of parameters for command and check for invalid command
        param_count = param_counts.get(cmd)
        if param_count is None:
            raise ValueError(f"unknown command {cmd}")

        if i + param_count > len(tokens):
            raise ValueError(f"not enough parameters for command {cmd}")

        params = [num(tokens[j]) for j in range(i, i + param_count)]  # get parameters
        i += param_count  # iterate current index to account for parameters

        if cmd in "Mm":
            path_data.append(command_map[cmd](*params))
            # moveto commands add an implicit lineto for subsequent pairs of coordinates
            cmd = "L" if cmd == "M" else "l"
        elif cmd in "Aa":
            # arc commands have boolean parameters
            rx, ry, angle, la, sw, px, py = params
            path_data.append(
                command_map[cmd](rx, ry, angle, bool(la), bool(sw), px, py)
            )
        else:
            path_data.append(command_map[cmd](*params))

    # find bounding box
    path = parse_path(path)
    xmin, xmax, ymin, ymax = path.bbox()
    width = xmax - xmin
    height = ymax - ymin

    return path_data, width, height, xmin, ymin


def get_events(start: Week, end: Week) -> list[dict]:
    """Get events between two weeks (inclusive)"""

    if start.academic_year != end.academic_year:
        raise ValueError("Start and end week must be in the same academic year")
    if start.term != end.term:
        raise ValueError("Start and end week must be in the same term")
    if start.week > end.week:
        raise ValueError("Start week must be before or equal to end week")

    events = get_events_in_week_range(start, end)

    return group_events(events)


def get_event_groups(  # noqa: PLR0915
    events: list[int],
) -> tuple[list[list[int]], list[list[int]]]:
    """Pack events into groups and return group dimensions and layout"""

    # allowed shapes for groups (cols, rows)
    # in prefrence order (prefer taller shapes)
    combinations = {
        1: [[1, 1]],
        2: [[2, 1], [1, 2]],
        3: [[3, 1], [1, 3], [2, 2]],
        4: [[2, 2], [4, 1], [1, 4]],
        5: [[3, 2], [2, 3], [4, 2]],
        6: [[3, 2], [2, 3], [4, 2]],
    }

    # track best layout found
    best_layout = {
        # metric: (area, empty cells, width, height)
        "metric": (float("inf"), float("inf"), float("inf"), float("inf")),
        "layout": [],
        "grid": [],
    }

    def get_metric(grid: list[list[int]]) -> tuple[int, int, int, int]:
        """calculate layout metric"""
        # find bounding box of used cells
        max_y = -1
        max_x = -1
        for y in range(MAX_GRID_ROWS):
            for x in range(MAX_GRID_COLS):
                if grid[y][x] != -1:
                    max_y = max(max_y, y)
                    max_x = max(max_x, x)
        # if no cells used, return infinity
        if max_x == -1 or max_y == -1:
            return (int(1e9), int(1e9), int(1e9), int(1e9))
        area = (max_x + 1) * (max_y + 1)

        # count empty cells in bounding box
        empty_cells = 0
        for y in range(max_y + 1):
            for x in range(max_x + 1):
                if grid[y][x] == -1:
                    empty_cells += 1
        return (area, empty_cells, max_x + 1, max_y + 1)

    def fits(shape: list[int], grid: list[list[int]], position: list[int]) -> bool:
        """check if shape fits in grid at position"""
        cols, rows = shape
        x, y = position
        if x + cols > MAX_GRID_COLS or y + rows > MAX_GRID_ROWS:
            return False
        for j in range(rows):
            for i in range(cols):
                if grid[y + j][x + i] != -1:
                    return False
        return True

    def place(
        i: int, shape: list[int], grid: list[list[int]], position: list[int]
    ) -> list[list[int]]:
        """place a shape i in grid at position"""
        new_grid = [row.copy() for row in grid]
        cols, rows = shape
        x, y = position
        for j in range(y, y + rows):
            for k in range(x, x + cols):
                new_grid[j][k] = i
        return new_grid

    def next_empty(grid: list[list[int]]) -> list[int] | None:
        """find next empty cell in grid"""
        for y in range(MAX_GRID_ROWS):
            for x in range(MAX_GRID_COLS):
                if grid[y][x] == -1:
                    return [x, y]
        return None

    def update_best(grid: list[list[int]], layout: dict[int, list[int]]) -> None:
        """update best layout if current is better"""
        metric = get_metric(grid)
        if metric < best_layout["metric"]:
            best_layout["metric"] = metric
            best_layout["layout"] = dict(layout)
            best_layout["grid"] = [row.copy() for row in grid]

    def backtrack(
        grid: list[list[int]], layout: dict[int, list[int]], remaining: set[int]
    ) -> None:
        """recursive backtracking to find best layout"""
        area, _, _, _ = get_metric(grid)
        if area > best_layout["metric"][0]:
            # if area already worse than best, prune
            return

        if not remaining:
            # if no remaining events, update best layout
            update_best(grid, layout)
            return

        location = next_empty(grid)
        if location is None:
            # if no more locations, this layout is invalid
            return

        for i in list(remaining):
            # iterate over remaining events

            num_events = events[i]

            if num_events not in combinations:
                # if dont have predefined shapes, use single column
                shape = [min(num_events, MAX_GRID_COLS), 1]
                if fits(shape, grid, location):
                    new_grid = place(i, shape, grid, location)
                    layout[i] = shape
                    backtrack(new_grid, layout, remaining - {i})
                    layout.pop(i, None)
            else:
                # otherwise try all predefined shapes (in preference order)
                for shape in combinations[num_events]:
                    if fits(shape, grid, location):
                        new_grid = place(i, shape, grid, location)
                        layout[i] = shape
                        backtrack(new_grid, layout, remaining - {i})
                        layout.pop(i, None)

    initial_grid = [[-1 for _ in range(MAX_GRID_COLS)] for _ in range(MAX_GRID_ROWS)]
    backtrack(initial_grid, {}, set(range(len(events))))

    if best_layout["metric"][0] == float("inf"):
        raise ValueError("Could not automatically generate grid, please do manually")

    layouts = [best_layout["layout"][i] for i in range(len(events))]
    # trim unused rows from grid
    trimmed_grid = [row for row in best_layout["grid"] if any(c != -1 for c in row)]
    return layouts, trimmed_grid


def split_text(text: str, max_chars: int) -> list[str]:
    """split a title into multiple lines if too long"""
    if len(text) <= max_chars:
        return [text]

    words = text.split()
    lines = []
    current_line = ""
    for word in words:
        if len(current_line) + len(word) + 1 <= max_chars:
            current_line += (" " if current_line else "") + word
        else:
            lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines


def get_event_circle(event: dict) -> svg.G:
    """Create a circle for an event"""
    icon = event.get("icon", "")
    if icon is not None:
        icon = icon.lower().removeprefix("ph-")
    title = split_text(event["name"], 12)
    location = split_text(event["location"], 15)
    colour = colours[event.get("colour", "blue").lower()]
    start_time = event["start_time"]
    time_format = "%I%p" if start_time.minute == 0 else "%I:%M%p"
    time_str = start_time.strftime(time_format).lstrip("0")

    # sizing params
    radius = CIRCLE_SIZE / 2
    text_top = CIRCLE_SIZE / 8 if icon else -CIRCLE_SIZE / 20
    title_size = CIRCLE_SIZE / 8 if len(title) == 1 else CIRCLE_SIZE / 10
    location_size = CIRCLE_SIZE / 13 if len(location) == 1 else CIRCLE_SIZE / 16
    time_size = location_size
    font_sizes = (
        [title_size] * len(title) + [location_size] * len(location) + [time_size]
    )

    elements: list[svg.Element] = [svg.Circle(cx=0, cy=0, r=radius, fill=colour)]

    if icon and icon in icon_paths:
        path, width, height, min_x, min_y = convert_path_to_list(icon_paths[icon])

        # scale the icon to be 150x150 max
        desired_size = CIRCLE_SIZE / 2.666
        scale = desired_size / max(width, height)

        # centre the icon vertically in the space above the text
        target_y = (-radius + text_top) / 2

        elements.append(
            svg.Path(
                d=path,
                fill="white",
                transform=[
                    svg.Translate(0, target_y),  # move to centre position
                    svg.Scale(scale),  # scale to desired size
                    svg.Translate(-min_x - width / 2, -min_y - height / 2),  # centre
                ],
            )
        )

    lines = title + location + [time_str]
    current_y = text_top
    for line, size in zip(lines, font_sizes):
        elements.append(
            svg.Text(
                text=line,
                x=0,
                y=current_y,
                font_size=size,
                text_anchor="middle",
                class_=["title" if size >= title_size else "text"],
            )
        )
        current_y += size

    return svg.G(elements=elements)


def get_socials(width: float, height: float) -> svg.G:
    """Create socials box"""
    desired_icon_width = width / 8
    icons = ["globe", "discord-logo", "instagram-logo", "linkedin-logo", "warwicksu"]
    text = ["uwcs.co.uk", "discord.uwcs.uk", "warwickcompsoc", "uwcs", "computing"]
    elements = [
        # base rectangle
        svg.Rect(
            x=0,
            y=0,
            width=width,
            height=height,
            fill=colours["greyer"],
            rx=40,
            ry=40,
        ),
        # join us text
        svg.Text(
            text="JOIN US",
            x=width / 2,
            y=height / 7,
            font_size=height / 10,
            text_anchor="middle",
            class_=["title"],
        ),
    ]
    for i, (icon, social_text) in enumerate(zip(icons, text), start=2):
        path, icon_width, icon_height, min_x, min_y = convert_path_to_list(
            icon_paths[icon]
        )
        scale = desired_icon_width / icon_width
        cx = (min_x + icon_width / 2) * scale
        cy = (min_y + icon_height / 2) * scale
        elements.extend(
            [
                svg.Path(
                    d=path,
                    transform=[
                        svg.Translate(width / 8 - cx, i * height / 7 - cy),
                        svg.Scale(scale),
                    ],
                    fill="white",
                ),
                svg.Text(
                    text=social_text,
                    x=width / 8 + desired_icon_width,
                    y=i * height / 7,
                    font_size=desired_icon_width / 1.75,
                    text_anchor="start",
                    dominant_baseline="middle",
                    class_=["text"],
                ),
            ]
        )
    return svg.G(elements=elements)


def create_single_week(events: list[dict], week: Week) -> list[svg.Element]:
    """Create the calendar for a single week"""

    elements: list[svg.Element] = [
        # add week text
        svg.Text(
            text=f"Week {week.week}",
            x=POST_WIDTH / 2,
            y=POST_HEIGHT / 4,
            font_size=TITLE_SIZE,
            text_anchor="middle",
            class_=["title"],
        ),
    ]

    # get the events for the week
    # find the list of weeks in the term
    term_weeks = events[0]["terms"][week.term - 1]["weeks"]
    # because terms can start at negative weeks, have gaps, and use different indexing
    # loop over the weeks to find the correct one
    week_days = []
    for w in term_weeks:
        if w["week"] == week.week:
            week_days = w["days"]
            break

    # group events by day and create layout
    # calculate the number of events each day
    num_events = [len(day["events"]) for day in week_days]

    # if odd, add 1 (the social links) to make even so we can make perfect grid
    if sum(num_events) % 2 != 0:
        num_events.append(1)
        week_days.append({"day": "Socials", "events": []})

    # find best way to split events into groups
    shapes, grid = get_event_groups(num_events)

    # find size of grid
    num_rows, num_cols = len(grid), len(grid[0])

    # find position and sizing of grid
    grid_height = POST_HEIGHT / 1.5
    grid_width = POST_WIDTH
    grid_top = POST_HEIGHT / 4 + (POST_HEIGHT - POST_HEIGHT / 4 - grid_height) / 2

    # find sizing of cells
    cell_width = grid_width / num_cols
    cell_height = grid_height / num_rows
    padding_x = cell_width * (1 - CELL_PADDING) / 2
    padding_y = cell_height * (1 - CELL_PADDING) / 2

    for i, day_events in enumerate(week_days):
        # extract info from existing arrays
        day, day_event_list = day_events["day"], day_events["events"]
        row_width, col_width = shapes[i]

        # find position of cells in grid
        found = False
        base_row = base_col = 0
        for row in range(num_rows):
            for col in range(num_cols):
                if grid[row][col] == i:
                    base_row, base_col = row, col
                    found = True
                    break
            if found:
                break

        # calculate initial offset (top left of first cell)
        base_x = base_col * cell_width
        base_y = grid_top + base_row * cell_height
        centre_y = base_y + col_width * cell_height / 2 + DAY_TEXT_HEIGHT / 2

        if day == "Socials":
            # apply socials box if necessary
            socials = get_socials(
                cell_width - 2 * padding_x,
                cell_height - 2 * padding_y,
            )
            socials.transform = [svg.Translate(base_x + padding_x, base_y + padding_y)]
            elements.append(socials)
            continue

        # add background rectangle and day text
        elements.extend(
            [
                svg.Rect(
                    x=base_x + padding_x,
                    y=base_y + padding_y,
                    width=row_width * cell_width - 2 * padding_x,
                    height=col_width * cell_height - 2 * padding_y,
                    rx=40,
                    ry=40,
                    fill=colours["greyer"],
                ),
                svg.Text(
                    text=day,
                    x=base_x + (row_width * cell_width) / 2,
                    y=base_y + DAY_TEXT_HEIGHT,
                    font_size=DAY_TEXT_SIZE,
                    text_anchor="middle",
                    class_=["title"],
                ),
            ]
        )

        for row in range(col_width):
            for col in range(row_width):
                # work out extra translation required
                translate_x = base_x + col * cell_width + cell_width / 2
                translate_y = (
                    base_y + row * cell_height + cell_height / 2 + DAY_TEXT_HEIGHT / 2
                )

                # if spanning multiple columns, pull towards centre
                pull = 0 if col_width == 1 else 0.2
                translate_y = (1 - pull) * translate_y + pull * centre_y

                # create event circle and apply offset
                event_idx = row * row_width + col
                event_circle = get_event_circle(day_event_list[event_idx])
                event_circle.transform = [svg.Translate(translate_x, translate_y)]
                elements.append(event_circle)

    return elements


def create_multi_week(events: list[dict], start: Week, end: Week) -> list[svg.Element]:
    """Create the calendar for multiple weeks (max 5)"""

    if end.week - start.week + 1 > MAX_WEEKS:
        raise ValueError("Cannot create calendar for more than 5 weeks")

    elements = [
        svg.Text(
            text=f"Term {start.term} Calendar",
            x=POST_HEIGHT / 2,
            y=POST_HEIGHT / 4,
            font_size=TITLE_SIZE,
            text_anchor="middle",
            class_=["title"],
        )
    ]

    # find the list of weeks in term
    term_weeks = events[start.academic_year]["terms"][start.term - 1]["weeks"]

    return elements


def create_svg(start: Week, end: Week) -> str:
    """Create publicity SVG calenndar for events between two weeks (inclusive)"""

    # base64 encode fonts to make svg self-contained
    # cairosvg only supports ttf and otf fonts
    montserrat_500 = get_b64_font("static/fonts/montserrat-bold.ttf")
    montserrat_600 = get_b64_font("static/fonts/montserrat-semibold.ttf")

    elements = [
        # define fonts
        svg.Style(
            text=f"""
                @font-face {{
                    font-family: 'montserrat-bold';
                    src: url({montserrat_600}) format('truetype');
                }}

                .title {{
                    font-family: 'montserrat-bold';
                    font-weight: 600;
                    fill: white;
                }}

                @font-face {{
                    font-family: 'montserrat-semibold';
                    src: url({montserrat_500}) format('truetype');
                }}

                .text {{
                    font-family: 'montserrat-semibold';
                    font-weight: 500;
                    fill: white;
                }}
            """
        ),
        # background
        svg.Rect(width=POST_WIDTH, height=POST_HEIGHT, fill=colours["grey"]),
        *random_dots(),  # add dots
        svg.Ellipse(  # blue background with curve at top
            cx=POST_WIDTH / 2, cy=BLUE_Y, rx=BLUE_RX, ry=BLUE_RY, fill=colours["blue"]
        ),
        # uwcs logo
        svg.G(
            elements=[
                svg.SVG(
                    viewBox=svg.ViewBoxSpec(0, 0, 450, 512),
                    elements=[
                        svg.Circle(cx=57, cy=21, r=21, fill=colours["yellow"]),
                        svg.Circle(cx=21, cy=57, r=21, fill=colours["yellow"]),
                        svg.Circle(cx=57, cy=95, r=21, fill=colours["blue"]),
                        svg.Circle(cx=93, cy=131, r=21, fill=colours["blue"]),
                        # i am so sorry for this
                        svg.Path(
                            d=convert_path_to_list(
                                "M148.879 92.6014c1.222 1.2505 2.691 2.232 4.313 2.8818 1.623.6498 3.362.9535 5.108.8918 1.678.0612 3.35-.2416 4.9-.8875 1.55-.6459 2.943-1.6197 4.082-2.8546 2.404-2.7703 3.643-6.3661 3.455-10.0316V43.7329h17.241V82.6013c.092 5.2481-1.186 10.4294-3.706 15.0316-2.386 4.2821-5.995 7.7531-10.364 9.9691-4.877 2.411-10.264 3.608-15.702 3.49-5.499.12-10.946-1.077-15.89-3.49-4.42-2.212-8.09-5.679-10.552-9.9691-2.549-4.5913-3.828-9.7802-3.706-15.0316V43.7329h17.241V82.6013c-.097 1.8215.169 3.6443.784 5.3614.614 1.7171 1.565 3.2942 2.796 4.6387Z"  # noqa: E501
                            )[0],
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M290.01 43.7329h17.712L285.393 109.771H267.681L255.12 64.7709 242.558 109.771H224.72L202.486 43.7329h18.56l13.002 48.3024L247.08 43.7329h16.864l13.19 48.3024L290.01 43.7329Z"  # noqa: E501
                            )[0],
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M362.46 59.7079c2.913 1.6292 5.466 3.833 7.505 6.4781l9.987-12.0756c-3.431-3.5985-7.569-6.4465-12.154-8.3648-5.185-2.225-10.803-3.2558-16.44-3.0164-5.636.2395-11.147 1.7431-16.126 4.4-5.3 2.8695-9.714 7.1398-12.759 12.3462-3.045 5.2064-4.606 11.1494-4.513 17.1824-.086 6.1487 1.476 12.2081 4.522 17.5474 2.993 5.1817 7.335 9.4528 12.562 12.3588 4.909 2.761 10.405 4.307 16.032 4.509 5.627.202 11.22-.945 16.314-3.346 4.805-2.135 9.147-5.191 12.782-8.9935L370.091 87.8844c-2.272 2.3529-4.954 4.2711-7.914 5.6604-2.639 1.3084-5.535 2.0171-8.479 2.0755-3.211.0285-6.365-.8429-9.107-2.5157-2.672-1.6911-4.841-4.0695-6.281-6.8869-1.549-3.0212-2.356-6.3683-2.356-9.7643 0-3.3959.807-6.743 2.356-9.7642 1.44-2.8174 3.609-5.1959 6.281-6.8869 2.744-1.6634 5.899-2.524 9.107-2.4843 3.075.0445 6.089.8666 8.762 2.3899Z"  # noqa: E501
                            )[0],
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M431.172 58.5447c3.929 1.2914 7.708 2.9992 11.274 5.0944l6.501-13.7737c-3.799-2.3955-7.925-4.2279-12.248-5.4403-4.591-1.3409-9.349-2.0186-14.132-2.0126-4.755-.1015-9.484.7429-13.912 2.4843-3.696 1.4454-6.901 3.923-9.233 7.1385-2.149 3.1652-3.248 6.9284-3.14 10.7548-.196 3.73.915 7.4113 3.14 10.4089 2.019 2.5413 4.628 4.5493 7.6 5.8491 3.645 1.5343 7.391 2.8161 11.212 3.8366 3.014.8176 5.338 1.5094 7.003 2.1069 1.528.5232 2.938 1.3464 4.145 2.4214.534.4703.96 1.0514 1.248 1.7031.287.6517.429 1.3582.416 2.0705.035.8286-.154 1.6511-.546 2.3814-.393.7304-.974 1.3416-1.683 1.7696-1.846 1.0366-3.948 1.5273-6.061 1.4151-4.186-.1487-8.303-1.1099-12.122-2.8302-4.315-1.7424-8.306-4.1979-11.808-7.2642l-6.689 13.4907c4.174 3.454 8.942 6.118 14.069 7.862 5.249 1.89 10.783 2.868 16.361 2.893 4.609.061 9.188-.738 13.504-2.359 3.741-1.411 7.007-3.853 9.421-7.044 2.375-3.2627 3.601-7.2222 3.486-11.2578.194-3.8272-.913-7.6072-3.14-10.7234-2.018-2.6349-4.663-4.7215-7.694-6.0692-3.687-1.5711-7.475-2.8948-11.337-3.9624-3.078-.9434-5.402-1.7295-6.972-2.327-1.456-.5286-2.799-1.3289-3.957-2.3585-.514-.4494-.924-1.0059-1.2-1.6307-.277-.6247-.414-1.3025-.401-1.9857-.034-.6872.117-1.3708.437-1.9794.321-.6086.799-1.1197 1.384-1.4798 1.543-.854 3.295-1.2571 5.056-1.1635 3.422.137 6.801.8053 10.018 1.9811Z"  # noqa: E501
                            )[0],
                            fill="white",
                        ),
                    ],
                )
            ],
            # transform and position correctly
            transform=[
                svg.Scale(LOGO_SCALE),
                svg.Translate(LOGO_TRANSLATE_X, LOGO_TRANSLATE_Y),
            ],
        ),
    ]

    events = get_events(start, end)
    if start == end:
        elements.extend(create_single_week(events, start))
    else:
        elements.extend(create_multi_week(events, start, end))

    return str(
        svg.SVG(
            elements=elements, viewBox=svg.ViewBoxSpec(0, 0, POST_WIDTH, POST_HEIGHT)
        )
    )
