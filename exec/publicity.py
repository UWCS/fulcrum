import base64
import math
import random
import re
from collections import deque
from pathlib import Path

import svg

from config import colours, icon_paths
from events.utils import get_events_in_week_range, group_events
from schema import Week


# this was entirely generated by chatgpt good look debugging :)
def poisson_disc_samples(
    width: int, height: int, radius: int, k: int
) -> list[tuple[float, float]]:
    """Poisson disc sampling using bridson's algorithm"""
    cell_size = radius / math.sqrt(2)
    grid_width = math.ceil(width / cell_size)
    grid_height = math.ceil(height / cell_size)

    grid = [[None for _ in range(grid_height)] for _ in range(grid_width)]
    points = []
    active = deque()

    first_point = (random.uniform(0, width), random.uniform(0, height))  # noqa: S311
    points.append(first_point)
    active.append(first_point)

    grid_x, grid_y = int(first_point[0] // cell_size), int(first_point[1] // cell_size)
    grid[grid_x][grid_y] = first_point  # type: ignore

    while active:
        idx = random.randrange(len(active))  # noqa: S311
        point = active[idx]
        found = False

        for _ in range(k):
            r = random.uniform(radius, 2 * radius)  # noqa: S311
            angle = random.uniform(0, 2 * math.pi)  # noqa: S311
            new_point = (point[0] + r * math.cos(angle), point[1] + r * math.sin(angle))

            if not (0 <= new_point[0] < width and 0 <= new_point[1] < height):
                continue

            grid_x, grid_y = int(new_point[0] // cell_size), int(
                new_point[1] // cell_size
            )
            too_close = False

            for i in range(max(0, grid_x - 2), min(grid_width, grid_x + 3)):
                for j in range(max(0, grid_y - 2), min(grid_height, grid_y + 3)):
                    neighbor = grid[i][j]
                    if neighbor and math.dist(new_point, neighbor) < radius:
                        too_close = True
                        break
                if too_close:
                    break

            if not too_close:
                points.append(new_point)
                active.append(new_point)
                grid[grid_x][grid_y] = new_point  # type: ignore
                found = True
                break

        if not found:
            active.remove(point)

    return points


def random_dots() -> list[svg.Element]:
    """generate random dots using poisson disc sampling"""

    # params
    num_dots = 30
    x = 2028
    y = 436
    spacing = 100
    k = 30  # limit of samples before rejection
    opacity = 0.4

    points = poisson_disc_samples(x, y, spacing, k)

    if len(points) > num_dots:
        points = random.sample(points, num_dots)

    dot_colours = [colours["greyer"], colours["blue"], colours["yellow"]]

    dots = []
    for cx, cy in points:
        fill = random.choice(dot_colours)  # noqa: S311
        dots.append(
            svg.Circle(
                cx=cx,
                cy=cy,
                r=13,
                fill=fill,
                opacity=opacity,
            )
        )
    return dots


def get_b64_font(path: str) -> str:
    """get base64 encoded font from path"""
    with Path(path).open("rb") as f:
        bytes = f.read()
    encoded = base64.b64encode(bytes).decode("utf-8")
    return f"data:font/woff2;base64,{encoded}"


def convert_path_to_list(path: str) -> list["svg.PathData"]:
    """Converts an SVG path string to a list of svg.PathData objects"""

    num_regex = re.compile(r"[A-Za-z]|[+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]?\d+)?")

    def _num(num: str) -> float | int:
        f = float(num)
        return int(f) if f.is_integer() else f

    param_counts = {
        **dict.fromkeys("Zz", 0),
        **dict.fromkeys("HhVv", 1),
        **dict.fromkeys("MmLlTt", 2),
        **dict.fromkeys("SsQq", 4),
        **dict.fromkeys("Cc", 6),
        **dict.fromkeys("Aa", 7),
    }

    command_map = {
        "L": svg.LineTo,
        "l": svg.LineToRel,
        "H": svg.HorizontalLineTo,
        "h": svg.HorizontalLineToRel,
        "V": svg.VerticalLineTo,
        "v": svg.VerticalLineToRel,
        "C": svg.CubicBezier,
        "c": svg.CubicBezierRel,
        "S": svg.SmoothCubicBezier,
        "s": svg.SmoothCubicBezierRel,
        "Q": svg.QuadraticBezier,
        "q": svg.QuadraticBezierRel,
        "T": svg.SmoothQuadraticBezier,
        "t": svg.SmoothQuadraticBezierRel,
        "Z": svg.ClosePath,
        "z": svg.ClosePath,
    }

    tokens = num_regex.findall(path)
    i, cmd = 0, None
    path_data = []

    while i < len(tokens):
        tok = tokens[i]
        if tok.isalpha():
            cmd, i = tok, i + 1
            if cmd in "Zz":
                path_data.append(svg.ClosePath())
                continue

        if cmd is None:
            raise ValueError("invalid path data")

        param_count = param_counts.get(cmd)
        if param_count is None:
            raise ValueError(f"unknown command {cmd}")

        if i + param_count > len(tokens):
            raise ValueError(f"not enough parameters for command {cmd}")

        params = [_num(tokens[j]) for j in range(i, i + param_count)]
        i += param_count

        if cmd in "Mm":
            if cmd == "M":
                path_data.append(svg.MoveTo(*params))
                cmd = "L"
            else:
                path_data.append(svg.MoveToRel(*params))
                cmd = "l"
        elif cmd in "Aa":
            rx, ry, angle, la, sw, x, y = params
            arc_cls = svg.Arc if cmd == "A" else svg.ArcRel
            path_data.append(arc_cls(rx, ry, angle, bool(int(la)), bool(int(sw)), x, y))
        else:
            path_data.append(command_map[cmd](*params))

    return path_data


def get_events(start: Week, end: Week) -> list[dict]:
    """Get events between two weeks (inclusive)"""

    if start.academic_year != end.academic_year:
        raise ValueError("Start and end week must be in the same academic year")
    if start.term != end.term:
        raise ValueError("Start and end week must be in the same term")
    if start.week > end.week:
        raise ValueError("Start week must be before or equal to end week")

    events = get_events_in_week_range(start, end)

    return group_events(events)


def create_single_week(events: list[dict], week: Week) -> list[svg.Element]:
    return []


def create_multi_week(events: list[dict], start: Week, end: Week) -> list[svg.Element]:
    return []


def create_svg(start: Week, end: Week) -> str:
    """Create publicity SVG calenndar for events between two weeks (inclusive)"""

    # base64 encode fonts to make svg self-contained
    montserrat_500 = get_b64_font("static/fonts/montserrat-v26-latin-500.woff2")
    montserrat_600 = get_b64_font("static/fonts/montserrat-v26-latin-600.woff2")

    elements = [
        # define fonts
        svg.Style(
            text=f"""
                @font-face {{
                    font-family: 'montserrat-bold';
                    src: url({montserrat_600}) format('woff2');
                }}

                .title {{
                    font-family: 'montserrat-bold';
                    font-weight: 600;
                    fill: white;
                }}

                @font-face {{
                    font-family: 'montserrat-semibold';
                    src: url({montserrat_500}) format('woff2');
                }}

                .text {{
                    font-family: 'montserrat-semibold';
                    font-weight: 500;
                    fill: white;
                }}
            """
        ),
        svg.Rect(width=2028, height=2028, fill=colours["grey"]),  # background
        *random_dots(),  # add dots
        svg.Ellipse(  # blue background with curve at top
            cx=1024, cy=1914, rx=3002, ry=1566, fill=colours["blue"]
        ),
        # uwcs logo
        svg.G(
            elements=[
                svg.SVG(
                    viewBox=svg.ViewBoxSpec(0, 0, 450, 512),
                    elements=[
                        svg.Circle(cx=57, cy=21, r=21, fill=colours["yellow"]),
                        svg.Circle(cx=21, cy=57, r=21, fill=colours["yellow"]),
                        svg.Circle(cx=57, cy=95, r=21, fill=colours["blue"]),
                        svg.Circle(cx=93, cy=131, r=21, fill=colours["blue"]),
                        # i am so sorry for this
                        svg.Path(
                            d=convert_path_to_list(
                                "M148.879 92.6014c1.222 1.2505 2.691 2.232 4.313 2.8818 1.623.6498 3.362.9535 5.108.8918 1.678.0612 3.35-.2416 4.9-.8875 1.55-.6459 2.943-1.6197 4.082-2.8546 2.404-2.7703 3.643-6.3661 3.455-10.0316V43.7329h17.241V82.6013c.092 5.2481-1.186 10.4294-3.706 15.0316-2.386 4.2821-5.995 7.7531-10.364 9.9691-4.877 2.411-10.264 3.608-15.702 3.49-5.499.12-10.946-1.077-15.89-3.49-4.42-2.212-8.09-5.679-10.552-9.9691-2.549-4.5913-3.828-9.7802-3.706-15.0316V43.7329h17.241V82.6013c-.097 1.8215.169 3.6443.784 5.3614.614 1.7171 1.565 3.2942 2.796 4.6387Z"  # noqa: E501
                            ),
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M290.01 43.7329h17.712L285.393 109.771H267.681L255.12 64.7709 242.558 109.771H224.72L202.486 43.7329h18.56l13.002 48.3024L247.08 43.7329h16.864l13.19 48.3024L290.01 43.7329Z"  # noqa: E501
                            ),
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M362.46 59.7079c2.913 1.6292 5.466 3.833 7.505 6.4781l9.987-12.0756c-3.431-3.5985-7.569-6.4465-12.154-8.3648-5.185-2.225-10.803-3.2558-16.44-3.0164-5.636.2395-11.147 1.7431-16.126 4.4-5.3 2.8695-9.714 7.1398-12.759 12.3462-3.045 5.2064-4.606 11.1494-4.513 17.1824-.086 6.1487 1.476 12.2081 4.522 17.5474 2.993 5.1817 7.335 9.4528 12.562 12.3588 4.909 2.761 10.405 4.307 16.032 4.509 5.627.202 11.22-.945 16.314-3.346 4.805-2.135 9.147-5.191 12.782-8.9935L370.091 87.8844c-2.272 2.3529-4.954 4.2711-7.914 5.6604-2.639 1.3084-5.535 2.0171-8.479 2.0755-3.211.0285-6.365-.8429-9.107-2.5157-2.672-1.6911-4.841-4.0695-6.281-6.8869-1.549-3.0212-2.356-6.3683-2.356-9.7643 0-3.3959.807-6.743 2.356-9.7642 1.44-2.8174 3.609-5.1959 6.281-6.8869 2.744-1.6634 5.899-2.524 9.107-2.4843 3.075.0445 6.089.8666 8.762 2.3899Z"  # noqa: E501
                            ),
                            fill="white",
                        ),
                        svg.Path(
                            d=convert_path_to_list(
                                "M431.172 58.5447c3.929 1.2914 7.708 2.9992 11.274 5.0944l6.501-13.7737c-3.799-2.3955-7.925-4.2279-12.248-5.4403-4.591-1.3409-9.349-2.0186-14.132-2.0126-4.755-.1015-9.484.7429-13.912 2.4843-3.696 1.4454-6.901 3.923-9.233 7.1385-2.149 3.1652-3.248 6.9284-3.14 10.7548-.196 3.73.915 7.4113 3.14 10.4089 2.019 2.5413 4.628 4.5493 7.6 5.8491 3.645 1.5343 7.391 2.8161 11.212 3.8366 3.014.8176 5.338 1.5094 7.003 2.1069 1.528.5232 2.938 1.3464 4.145 2.4214.534.4703.96 1.0514 1.248 1.7031.287.6517.429 1.3582.416 2.0705.035.8286-.154 1.6511-.546 2.3814-.393.7304-.974 1.3416-1.683 1.7696-1.846 1.0366-3.948 1.5273-6.061 1.4151-4.186-.1487-8.303-1.1099-12.122-2.8302-4.315-1.7424-8.306-4.1979-11.808-7.2642l-6.689 13.4907c4.174 3.454 8.942 6.118 14.069 7.862 5.249 1.89 10.783 2.868 16.361 2.893 4.609.061 9.188-.738 13.504-2.359 3.741-1.411 7.007-3.853 9.421-7.044 2.375-3.2627 3.601-7.2222 3.486-11.2578.194-3.8272-.913-7.6072-3.14-10.7234-2.018-2.6349-4.663-4.7215-7.694-6.0692-3.687-1.5711-7.475-2.8948-11.337-3.9624-3.078-.9434-5.402-1.7295-6.972-2.327-1.456-.5286-2.799-1.3289-3.957-2.3585-.514-.4494-.924-1.0059-1.2-1.6307-.277-.6247-.414-1.3025-.401-1.9857-.034-.6872.117-1.3708.437-1.9794.321-.6086.799-1.1197 1.384-1.4798 1.543-.854 3.295-1.2571 5.056-1.1635 3.422.137 6.801.8053 10.018 1.9811Z"  # noqa: E501
                            ),
                            fill="white",
                        ),
                    ],
                )
            ],
            transform=[svg.Scale(0.35), svg.Translate(1887, 198)],
        ),
    ]

    events = get_events(start, end)
    if start == end:
        elements.extend(create_single_week(events, start))
    else:
        elements.extend(create_multi_week(events, start, end))

    return str(svg.SVG(elements=elements, viewBox=svg.ViewBoxSpec(0, 0, 2028, 2028)))
