import base64
import math
import random
from collections import deque
from pathlib import Path

import svg

from config import colours, icon_paths
from events.utils import get_events_in_week_range, group_events
from schema import Week


def get_events(start: Week, end: Week) -> list[dict]:
    """Get events between two weeks (inclusive)"""

    if start.academic_year != end.academic_year:
        raise ValueError("Start and end week must be in the same academic year")
    if start.term != end.term:
        raise ValueError("Start and end week must be in the same term")
    if start.week > end.week:
        raise ValueError("Start week must be before or equal to end week")

    events = get_events_in_week_range(start, end)

    return group_events(events)


def create_single_week(events: list[dict], week: Week) -> list[svg.Element]:
    return []


def create_multi_week(events: list[dict], start: Week, end: Week) -> list[svg.Element]:
    return []


# this was entirely generated by chatgpt good look debugging :)
def poisson_disc_samples(
    width: int, height: int, radius: int, k: int
) -> list[tuple[float, float]]:
    """Poisson disc sampling using bridson's algorithm"""
    cell_size = radius / math.sqrt(2)
    grid_width = math.ceil(width / cell_size)
    grid_height = math.ceil(height / cell_size)

    grid = [[None for _ in range(grid_height)] for _ in range(grid_width)]
    points = []
    active = deque()

    first_point = (random.uniform(0, width), random.uniform(0, height))  # noqa: S311
    points.append(first_point)
    active.append(first_point)

    grid_x, grid_y = int(first_point[0] // cell_size), int(first_point[1] // cell_size)
    grid[grid_x][grid_y] = first_point  # type: ignore

    while active:
        idx = random.randrange(len(active))  # noqa: S311
        point = active[idx]
        found = False

        for _ in range(k):
            r = random.uniform(radius, 2 * radius)  # noqa: S311
            angle = random.uniform(0, 2 * math.pi)  # noqa: S311
            new_point = (point[0] + r * math.cos(angle), point[1] + r * math.sin(angle))

            if not (0 <= new_point[0] < width and 0 <= new_point[1] < height):
                continue

            grid_x, grid_y = int(new_point[0] // cell_size), int(
                new_point[1] // cell_size
            )
            too_close = False

            for i in range(max(0, grid_x - 2), min(grid_width, grid_x + 3)):
                for j in range(max(0, grid_y - 2), min(grid_height, grid_y + 3)):
                    neighbor = grid[i][j]
                    if neighbor and math.dist(new_point, neighbor) < radius:
                        too_close = True
                        break
                if too_close:
                    break

            if not too_close:
                points.append(new_point)
                active.append(new_point)
                grid[grid_x][grid_y] = new_point  # type: ignore
                found = True
                break

        if not found:
            active.remove(point)

    return points


def random_dots() -> list[svg.Element]:
    num_dots = 20
    x = 2028
    y = 436
    spacing = 100
    k = 30

    points = poisson_disc_samples(x, y, spacing, k)

    if len(points) > num_dots:
        points = random.sample(points, num_dots)

    dot_colours = [colours["greyer"], colours["blue"], colours["yellow"]]
    dot_colours = [colour + "80" for colour in dot_colours]  # Add transparency
    transparent_chance = 0.3

    dots = []
    for cx, cy in points:
        stroke = random.choice(dot_colours)  # noqa: S311
        fill = stroke if random.random() > transparent_chance else "none"  # noqa: S311
        dots.append(
            svg.Circle(cx=cx, cy=cy, r=15, stroke=stroke, fill=fill, stroke_width=2)
        )
    return dots


def get_b64_font(path: str) -> str:
    with Path(path).open("rb") as f:
        bytes = f.read()
    encoded = base64.b64encode(bytes).decode("utf-8")
    return f"data:font/woff2;base64,{encoded}"


def create_svg(start: Week, end: Week) -> str:
    """Create publicity SVG calenndar for events between two weeks (inclusive)"""

    montserrat_500 = get_b64_font("static/fonts/montserrat-v26-latin-500.woff2")
    montserrat_600 = get_b64_font("static/fonts/montserrat-v26-latin-600.woff2")

    elements = [
        svg.Style(
            text=f"""
                @font-face {{
                    font-family: 'montserrat-bold';
                    src: url({montserrat_600}) format('woff2');
                }}

                .title {{
                    font-family: 'montserrat-bold';
                    font-weight: 600;
                    fill: white;
                }}

                @font-face {{
                    font-family: 'montserrat-semibold';
                    src: url({montserrat_500}) format('woff2');
                }}

                .text {{
                    font-family: 'montserrat-semibold';
                    font-weight: 500;
                    fill: white;
                }}
            """
        ),
        svg.Rect(width=2028, height=2028, fill=colours["grey"]),
        *random_dots(),
        svg.Ellipse(cx=1024, cy=1914, rx=3002, ry=1566, fill=colours["blue"]),
    ]

    events = get_events(start, end)
    if start == end:
        elements.extend(create_single_week(events, start))
    else:
        elements.extend(create_multi_week(events, start, end))

    return str(svg.SVG(elements=elements, viewBox=svg.ViewBoxSpec(0, 0, 2028, 2028)))
