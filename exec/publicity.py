import base64
import itertools
import math
import random
import re
from collections import deque
from pathlib import Path

import svg
from svgpathtools import parse_path

from config import colours, icon_paths
from events.utils import get_events_in_week_range, group_events
from schema import Week

# params for sizing for everything
POST_HEIGHT, POST_WIDTH = 2028, 2028

# logo shennanigans
LOGO_TRANSLATE_X = 718
LOGO_TRANSLATE_Y = 80

# space dots can be in
DOTS_X, DOTS_Y = POST_WIDTH, 436

# size of blue background
BLUE_Y = 1914
BLUE_RX = 3002
BLUE_RY = 1566

# size for title (week or term)
TITLE_SIZE = 110

# max grid size for single week
MAX_GRID_COLS = 4
MAX_GRID_ROWS = 3

# the options for sizes of a grid
GRID_SIZES = [(2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 3)]

# spacing of days in single week
DAY_TEXT_HEIGHT = 125
DAY_TEXT_SIZE = 70
CIRCLE_SIZE = 400

# cell sizing
CELL_PADDING = 0.9
CELL_RADIUS = 40

# max weeks for multi week
MAX_WEEKS = 5


# this was entirely generated by chatgpt good look debugging :)
def poisson_disc_samples(
    width: float, height: float, radius: float, k: int
) -> list[tuple[float, float]]:
    """Poisson disc sampling using bridson's algorithm"""
    cell_size = radius / math.sqrt(2)
    grid_width = math.ceil(width / cell_size)
    grid_height = math.ceil(height / cell_size)

    grid = [[None for _ in range(grid_height)] for _ in range(grid_width)]
    points = []
    active = deque()

    first_point = (random.uniform(0, width), random.uniform(0, height))  # noqa: S311
    points.append(first_point)
    active.append(first_point)

    grid_x, grid_y = int(first_point[0] // cell_size), int(first_point[1] // cell_size)
    grid[grid_x][grid_y] = first_point  # type: ignore

    while active:
        idx = random.randrange(len(active))  # noqa: S311
        point = active[idx]
        found = False

        for _ in range(k):
            r = random.uniform(radius, 2 * radius)  # noqa: S311
            angle = random.uniform(0, 2 * math.pi)  # noqa: S311
            new_point = (point[0] + r * math.cos(angle), point[1] + r * math.sin(angle))

            if not (0 <= new_point[0] < width and 0 <= new_point[1] < height):
                continue

            grid_x, grid_y = int(new_point[0] // cell_size), int(new_point[1] // cell_size)
            too_close = False

            for i in range(max(0, grid_x - 2), min(grid_width, grid_x + 3)):
                for j in range(max(0, grid_y - 2), min(grid_height, grid_y + 3)):
                    neighbor = grid[i][j]
                    if neighbor and math.dist(new_point, neighbor) < radius:
                        too_close = True
                        break
                if too_close:
                    break

            if not too_close:
                points.append(new_point)
                active.append(new_point)
                grid[grid_x][grid_y] = new_point  # type: ignore
                found = True
                break

        if not found:
            active.remove(point)

    return points


def random_dots() -> list[svg.Element]:
    """generate random dots using poisson disc sampling"""

    # params
    radius = 13
    opacity = 0.4
    num = 30
    spacing = radius * 10
    k = 30  # limit of samples before rejection

    points = poisson_disc_samples(DOTS_X, DOTS_Y, spacing, k)

    if len(points) > num:
        points = random.sample(points, num)

    dot_colours = [colours["greyer"], colours["blue"], colours["yellow"]]

    dots = []
    for cx, cy in points:
        fill = random.choice(dot_colours)  # noqa: S311
        dots.append(
            svg.Circle(
                cx=cx,
                cy=cy,
                r=radius,
                fill=fill,
                opacity=opacity,
            )
        )
    return dots


def convert_path_to_list(
    path: str,
) -> tuple[list[svg.PathData], float, float, float, float]:
    """
    Converts an SVG path string to a list of svg.PathData object
    also returns width, height, min_x, min_y of the path
    """

    # regex to match commands and numbers
    num_regex = re.compile(r"[A-Za-z]|[+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]?\d+)?")

    def num(num: str) -> float | int:
        """convert string to int if possible, else float"""
        f = float(num)
        return int(f) if f.is_integer() else f

    # number of parameters for each command
    param_counts = {
        **dict.fromkeys("Zz", 0),
        **dict.fromkeys("HhVv", 1),
        **dict.fromkeys("MmLlTt", 2),
        **dict.fromkeys("SsQq", 4),
        **dict.fromkeys("Cc", 6),
        **dict.fromkeys("Aa", 7),
    }

    # map commands to svg.PathData classes
    command_map = {
        "M": svg.MoveTo,
        "m": svg.MoveToRel,
        "L": svg.LineTo,
        "l": svg.LineToRel,
        "H": svg.HorizontalLineTo,
        "h": svg.HorizontalLineToRel,
        "V": svg.VerticalLineTo,
        "v": svg.VerticalLineToRel,
        "C": svg.CubicBezier,
        "c": svg.CubicBezierRel,
        "S": svg.SmoothCubicBezier,
        "s": svg.SmoothCubicBezierRel,
        "Q": svg.QuadraticBezier,
        "q": svg.QuadraticBezierRel,
        "T": svg.SmoothQuadraticBezier,
        "t": svg.SmoothQuadraticBezierRel,
        "A": svg.Arc,
        "a": svg.ArcRel,
        "Z": svg.ClosePath,
        "z": svg.ClosePath,
    }

    tokens = num_regex.findall(path)  # tokenise the path string
    i, cmd = 0, None  # current command
    path_data = []  # list of svg.PathData objects

    while i < len(tokens):
        tok = tokens[i]
        if tok.isalpha():  # if token is a letter, its a command
            cmd, i = tok, i + 1
            if cmd in "Zz":
                # z indicates closing the path
                path_data.append(svg.ClosePath())
                continue

        # no command
        if cmd is None:
            raise ValueError("invalid path data")

        # get number of parameters for command and check for invalid command
        param_count = param_counts.get(cmd)
        if param_count is None:
            raise ValueError(f"unknown command {cmd}")

        if i + param_count > len(tokens):
            raise ValueError(f"not enough parameters for command {cmd}")

        params = [num(tokens[j]) for j in range(i, i + param_count)]  # get parameters
        i += param_count  # iterate current index to account for parameters

        if cmd in "Mm":
            path_data.append(command_map[cmd](*params))
            # moveto commands add an implicit lineto for subsequent pairs of coordinates
            cmd = "L" if cmd == "M" else "l"
        elif cmd in "Aa":
            # arc commands have boolean parameters
            rx, ry, angle, la, sw, px, py = params
            path_data.append(command_map[cmd](rx, ry, angle, bool(la), bool(sw), px, py))
        else:
            path_data.append(command_map[cmd](*params))

    # find bounding box
    path = parse_path(path)
    xmin, xmax, ymin, ymax = path.bbox()
    width = xmax - xmin
    height = ymax - ymin

    return path_data, width, height, xmin, ymin


def get_events(start: Week, end: Week) -> list[dict]:
    """Get events between two weeks (inclusive)"""

    if start.academic_year != end.academic_year:
        raise ValueError("Start and end week must be in the same academic year")
    if start.term != end.term:
        raise ValueError("Start and end week must be in the same term")
    if start.week > end.week:
        raise ValueError("Start week must be before or equal to end week")

    events = get_events_in_week_range(start, end)

    return group_events(events)


def backtrack(groups: list[tuple[int, list[int]]], grid: list[list[int]]) -> list[list[int]] | None:
    """backtracking algorithm to fit items into grid"""

    # base case, just return grid, we good :)
    if not groups:
        return grid

    # get next group of events to place
    group_id, (width, height) = groups[0]
    remaining_groups = groups[1:]
    num_rows, num_cols = len(grid), len(grid[0])

    for row in range(num_rows - height + 1):
        for col in range(num_cols - width + 1):
            # check if space is free
            is_free = all(
                grid[i][j] == -1 for i in range(row, row + height) for j in range(col, col + width)
            )

            # try again if not free
            if not is_free:
                continue

            # place group in grid
            new_grid = [r.copy() for r in grid]
            for i in range(row, row + height):
                for j in range(col, col + width):
                    new_grid[i][j] = group_id

            # recurse for remaining groups
            solution = backtrack(remaining_groups, new_grid)

            # if solution found, return it
            if solution is not None:
                return solution

    # no solution found
    return None


def get_event_groups(
    event_groups: list[int],
) -> tuple[list[list[int]], list[list[int]]]:
    """Pack events into groups and return group dimensions and layout"""

    # allowed shapes for groups (width, height)
    combinations = {
        1: [[1, 1]],
        2: [[2, 1], [1, 2]],
        3: [[3, 1], [2, 2], [1, 3]],
        4: [[2, 2], [4, 1]],
        5: [[3, 2], [2, 3], [4, 2]],
        6: [[3, 2], [2, 3], [4, 2]],
    }

    # get possible sizes of grids
    grid_sizes = GRID_SIZES[int(sum(event_groups) / 2 - 1) :]

    # get all combinations of shapes for the event groups
    try:
        shape_options = [combinations[n] for n in event_groups]
    except KeyError:
        raise ValueError(
            f"Cannot fit more than {MAX_GRID_COLS * MAX_GRID_ROWS} events in a day"
        ) from None
    all_options = list(itertools.product(*shape_options))

    for num_cols, num_rows in grid_sizes:  # try smallest grids first
        for shape in all_options:  # try all shape combinations
            # [idx, (width, height)]
            items = list(enumerate(shape))

            base_grid = [[-1] * num_cols for _ in range(num_rows)]

            # try to fit items into grid
            layout = backtrack(items, base_grid)

            # if successful, return shape and layout
            if layout is not None:
                return list(shape), layout
    raise ValueError("Could not fit events into grid")


def split_text(text: str, max_chars: int) -> list[str]:
    """split a title into multiple lines if too long"""
    if len(text) <= max_chars:
        return [text]

    words = text.split()
    lines = []
    current_line = ""
    for word in words:
        if len(current_line) + len(word) + 1 <= max_chars:
            current_line += (" " if current_line else "") + word
        else:
            lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return lines


def get_event_circle(event: dict) -> svg.G:
    """Create a circle for an event"""
    icon = event.get("icon", "")
    if icon is not None:
        icon = icon.lower().removeprefix("ph-")
    title = split_text(event["name"], 12)
    location = split_text(event["location"], 15)
    colour = event.get("colour", colours["blue"])
    if not colour.startswith("#"):
        colour = colours.get(colour, colours["blue"])
    start_time = event["start_time"]
    time_format = "%I%p" if start_time.minute == 0 else "%I:%M%p"
    time_str = start_time.strftime(time_format).lstrip("0")

    # sizing params
    radius = CIRCLE_SIZE / 2
    text_top = CIRCLE_SIZE / 8 if icon else -CIRCLE_SIZE / 20
    title_size = CIRCLE_SIZE / 8 if len(title) == 1 else CIRCLE_SIZE / 10
    location_size = CIRCLE_SIZE / 13 if len(location) == 1 else CIRCLE_SIZE / 16
    time_size = location_size
    font_sizes = [title_size] * len(title) + [location_size] * len(location) + [time_size]

    elements: list[svg.Element] = [svg.Circle(cx=0, cy=0, r=radius, fill=colour)]

    if icon and icon in icon_paths:
        path, width, height, min_x, min_y = convert_path_to_list(icon_paths[icon])

        # scale the icon to be 150x150 max
        desired_size = CIRCLE_SIZE / 2.666
        scale = desired_size / max(width, height)

        # centre the icon vertically in the space above the text
        target_y = (-radius + text_top) / 2

        elements.append(
            svg.Path(
                d=path,
                fill="white",
                transform=[
                    svg.Translate(0, target_y),  # move to centre position
                    svg.Scale(scale),  # scale to desired size
                    svg.Translate(-min_x - width / 2, -min_y - height / 2),  # centre
                ],
            )
        )

    lines = title + location + [time_str]
    current_y = text_top
    for line, size in zip(lines, font_sizes, strict=True):
        elements.append(
            svg.Text(
                text=line,
                x=0,
                y=current_y,
                font_size=size,
                text_anchor="middle",
                class_=["title" if size >= title_size else "text"],
            )
        )
        current_y += size

    return svg.G(elements=elements)


def get_socials(width: float, height: float) -> svg.G:
    """Create socials box"""
    desired_icon_width = width / 12
    icons = [
        "globe",
        "discord-logo",
        "instagram-logo",
        "linkedin-logo",
        "warwicksu",
        "linktree-logo",
    ]
    text = [
        "uwcs.co.uk",
        "discord.uwcs.uk",
        "warwickcompsoc",
        "uwcs",
        "computing",
        "warwickcompsoc",
    ]
    num_rows = len(icons) + 2
    elements = [
        # base rectangle
        svg.Rect(
            x=0,
            y=0,
            width=width,
            height=height,
            fill=colours["greyer"],
            rx=CELL_RADIUS,
            ry=CELL_RADIUS,
        ),
        # join us text
        svg.Text(
            text="JOIN US",
            x=width / 2,
            y=height / num_rows,
            font_size=height / 10,
            text_anchor="middle",
            class_=["title"],
        ),
    ]
    for i, (icon, social_text) in enumerate(zip(icons, text, strict=True), start=2):
        path, icon_width, icon_height, min_x, min_y = convert_path_to_list(icon_paths[icon])
        scale = desired_icon_width / icon_width
        cx = (min_x + icon_width / 2) * scale
        cy = (min_y + icon_height / 2) * scale
        elements.extend(
            [
                svg.Path(
                    d=path,
                    transform=[
                        svg.Translate(width / 5 - cx, i * height / num_rows - cy),
                        svg.Scale(scale),
                    ],
                    fill="white",
                ),
                svg.Text(
                    text=social_text,
                    x=width / 5 + desired_icon_width,
                    y=i * height / num_rows,
                    font_size=desired_icon_width / 1.5,
                    text_anchor="start",
                    dominant_baseline="middle",
                    class_=["text"],
                ),
            ]
        )
    return svg.G(elements=elements)


def create_single_week(  # noqa: PLR0912, PLR0915
    events: list[dict], week: Week
) -> list[svg.Element]:
    """Create the calendar for a single week"""

    elements: list[svg.Element] = [
        # add week text
        svg.Text(
            text=f"Week {week.week}",
            x=POST_WIDTH / 2,
            y=POST_HEIGHT / 4,
            font_size=TITLE_SIZE,
            text_anchor="middle",
            class_=["title"],
        ),
    ]

    # get the events for the week
    # find the list of weeks in the term
    try:
        term_weeks = events[0]["terms"][0]["weeks"]
    except (IndexError, KeyError):
        raise ValueError("No events found for this week") from None
    # because terms can start at negative weeks, have gaps, and use different indexing
    # loop over the weeks to find the correct one
    week_days = []
    for w in term_weeks:
        if w["week"] == week.week:
            week_days = w["days"]
            break

    # group events by day and create layout
    # calculate the number of events each day
    num_events = [len(day["events"]) for day in week_days]

    # if odd, add 1 (the social links) to make even so we can make perfect grid
    if sum(num_events) % 2 != 0:
        num_events.append(1)
        week_days.append({"day": "Socials", "events": []})

    # find best way to split events into groups
    shapes, grid = get_event_groups(num_events)

    # find size of grid
    num_rows, num_cols = len(grid), len(grid[0])

    # find position and sizing of grid
    grid_height = (POST_HEIGHT / 1.5) if num_rows < 3 else (POST_HEIGHT / 1.35)  # noqa: PLR2004
    grid_width = POST_WIDTH
    grid_top = POST_HEIGHT / 4 + (POST_HEIGHT - POST_HEIGHT / 4 - grid_height) / 2

    # sizing factors
    pull_factor = 0.2
    two_col_shrink_x = 0.7
    two_col_shrink_y = 0.5

    # find sizing of cells
    if num_cols == 2:  # noqa: PLR2004
        # if only two columns, shrink grid to make it look better
        grid_width *= two_col_shrink_x
        grid_left = (POST_WIDTH - grid_width) / 2
        if num_rows == 1:
            # if only one row, shrink vertically too
            orig_grid_height = grid_height
            grid_height *= two_col_shrink_y
            grid_top += (orig_grid_height - grid_height) / 2
    else:
        grid_left = 0
    cell_height = grid_height / num_rows
    cell_width = grid_width / num_cols
    padding_x = cell_width * (1 - CELL_PADDING) / 2
    padding_y = cell_height * (1 - CELL_PADDING) / 2

    for i, day_events in enumerate(week_days):
        # extract info from existing arrays
        day, day_event_list = day_events["day"], day_events["events"]
        row_width, col_width = shapes[i]

        # find position of cells in grid
        found = False
        base_row = base_col = 0
        for row in range(num_rows):
            for col in range(num_cols):
                if grid[row][col] == i:
                    base_row, base_col = row, col
                    found = True
                    break
            if found:
                break

        # calculate initial offset (top left of first cell)
        base_x = grid_left + base_col * cell_width
        base_y = grid_top + base_row * cell_height
        centre_y = base_y + col_width * cell_height / 2 + DAY_TEXT_HEIGHT / 2

        if day == "Socials":
            # apply socials box if necessary
            socials = get_socials(
                cell_width - 2 * padding_x,
                cell_height - 2 * padding_y,
            )
            socials.transform = [svg.Translate(base_x + padding_x, base_y + padding_y)]
            elements.append(socials)
            continue

        # add background rectangle and day text
        elements.extend(
            [
                svg.Rect(
                    x=base_x + padding_x,
                    y=base_y + padding_y,
                    width=row_width * cell_width - 2 * padding_x,
                    height=col_width * cell_height - 2 * padding_y,
                    rx=CELL_RADIUS,
                    ry=CELL_RADIUS,
                    fill=colours["greyer"],
                ),
                svg.Text(
                    text=day,
                    x=base_x + (row_width * cell_width) / 2,
                    y=base_y
                    + DAY_TEXT_HEIGHT
                    - (cell_height / 20 if num_rows == 3 else 0),  # noqa: PLR2004
                    font_size=DAY_TEXT_SIZE,
                    text_anchor="middle",
                    class_=["title"],
                ),
            ]
        )

        for col in range(col_width):
            for row in range(row_width):
                event_scale = 0.85 if num_rows == 3 else 1.0  # noqa: PLR2004

                # work out extra translation required
                translate_x = base_x + row * cell_width + cell_width / 2
                translate_y = base_y + col * cell_height + cell_height / 2 + DAY_TEXT_HEIGHT / 2

                # when 3 rows, events are too low
                if num_rows == 3:  # noqa: PLR2004
                    translate_y -= cell_height / 20

                # if spanning multiple columns, pull towards centre
                pull_y = 0 if col_width == 1 else pull_factor
                translate_y = (1 - pull_y) * translate_y + pull_y * centre_y

                translate_x /= event_scale
                translate_y /= event_scale

                # create event circle and apply offset + scaling around its center
                event_idx = col * row_width + row
                event_circle = get_event_circle(day_event_list[event_idx])
                event_circle.transform = [
                    svg.Scale(event_scale),
                    svg.Translate(translate_x, translate_y),
                ]
                elements.append(event_circle)

    return elements


def create_multi_week(events: list[dict], start: Week, end: Week) -> list[svg.Element]:
    """Create the calendar for multiple weeks (max 5)"""

    raise ValueError("Not implemented yet come back soonTM")

    if end.week - start.week + 1 > MAX_WEEKS:
        raise ValueError("Cannot create calendar for more than 5 weeks")

    elements = [
        svg.Text(
            text=f"Term {start.term} Calendar",
            x=POST_HEIGHT / 2,
            y=POST_HEIGHT / 4,
            font_size=TITLE_SIZE,
            text_anchor="middle",
            class_=["title"],
        )
    ]

    # find the list of weeks in term
    term_weeks = events[start.academic_year]["terms"][0]["weeks"]  # noqa: F841

    return elements


def get_b64_font(path: str) -> str:
    """get base64 encoded font from path"""
    with Path(path).open("rb") as f:
        bytes = f.read()
    encoded = base64.b64encode(bytes).decode("utf-8")
    return f"data:font/ttf;base64,{encoded}"


def create_svg(start: Week, end: Week) -> str:
    """Create publicity SVG calenndar for events between two weeks (inclusive)"""

    # base64 encode fonts to make svg self-contained
    # cairosvg only supports ttf and otf fonts
    montserrat_500 = get_b64_font("static/fonts/montserrat-bold.ttf")
    montserrat_600 = get_b64_font("static/fonts/montserrat-semibold.ttf")

    elements = [
        # define fonts
        svg.Style(
            text=f"""
                @font-face {{
                    font-family: 'montserrat-bold';
                    src: url({montserrat_600}) format('truetype');
                }}

                .title {{
                    font-family: 'montserrat-bold';
                    font-weight: 600;
                    fill: white;
                }}

                @font-face {{
                    font-family: 'montserrat-semibold';
                    src: url({montserrat_500}) format('truetype');
                }}

                .text {{
                    font-family: 'montserrat-semibold';
                    font-weight: 500;
                    fill: white;
                }}
            """
        ),
        # background
        svg.Rect(width=POST_WIDTH, height=POST_HEIGHT, fill=colours["grey"]),
        *random_dots(),  # add dots
        svg.Ellipse(  # blue background with curve at top
            cx=POST_WIDTH / 2, cy=BLUE_Y, rx=BLUE_RX, ry=BLUE_RY, fill=colours["blue"]
        ),
        # uwcs logo
        svg.G(
            elements=[
                # i am so sorry for this
                svg.Path(
                    d=convert_path_to_list(
                        "M74.1765 54.1966C68.8169 54.1966 63.5777 52.6073 59.1214 49.6297C54.6651 46.6521 51.1919 42.42 49.1409 37.4684C47.0899 32.5168 46.5532 27.0683 47.5988 21.8117C48.6444 16.5552 51.2253 11.7267 55.015 7.93693C58.8048 4.14716 63.6333 1.56629 68.8898 0.520697C74.1464 -0.524898 79.595 0.0117467 84.5465 2.06275C89.4981 4.11376 93.7303 7.58702 96.7079 12.0433C99.6855 16.4996 101.275 21.7388 101.275 27.0983C101.269 34.2833 98.4116 41.1723 93.331 46.2529C88.2505 51.3335 81.3615 54.1905 74.1765 54.1966V54.1966Z",  # noqa: E501
                    )[0],
                    fill=colours["yellow"],
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M27.0983 101.509C42.0643 101.509 54.1966 89.3768 54.1966 74.4108C54.1966 59.4448 42.0643 47.3125 27.0983 47.3125C12.1323 47.3125 0 59.4448 0 74.4108C0 89.3768 12.1323 101.509 27.0983 101.509Z"  # noqa: E501
                    )[0],
                    fill=colours["yellow"],
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M74.1764 151.06C89.1424 151.06 101.275 138.928 101.275 123.962C101.275 108.996 89.1424 96.8633 74.1764 96.8633C59.2105 96.8633 47.0781 108.996 47.0781 123.962C47.0781 138.928 59.2105 151.06 74.1764 151.06Z"  # noqa: E501
                    )[0],
                    fill=colours["blue"],
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M121.745 198.626C136.711 198.626 148.843 186.494 148.843 171.528C148.843 156.562 136.711 144.43 121.745 144.43C106.779 144.43 94.6465 156.562 94.6465 171.528C94.6465 186.494 106.779 198.626 121.745 198.626Z"  # noqa: E501
                    )[0],
                    fill=colours["blue"],
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M196.583 121.433C198.197 123.084 200.136 124.38 202.278 125.238C204.42 126.096 206.717 126.497 209.023 126.416C211.239 126.497 213.446 126.097 215.492 125.244C217.539 124.391 219.378 123.105 220.883 121.475C224.057 117.817 225.692 113.069 225.444 108.229V56.9062H248.209V108.229C248.331 115.158 246.644 122 243.316 128.077C240.165 133.731 235.4 138.314 229.632 141.24C223.192 144.423 216.079 146.004 208.899 145.849C201.638 146.007 194.444 144.427 187.916 141.24C182.081 138.319 177.234 133.741 173.984 128.077C170.619 122.014 168.93 115.163 169.091 108.229V56.9062H191.856V108.229C191.727 110.634 192.079 113.041 192.89 115.308C193.702 117.575 194.958 119.658 196.583 121.433V121.433Z"  # noqa: E501
                    )[0],
                    fill="white",
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M382.933 56.9062H406.32L376.837 144.105H353.45L336.863 84.6851L320.277 144.105H296.724L267.365 56.9062H291.872L309.039 120.686L326.248 56.9062H348.516L365.932 120.686L382.933 56.9062Z"  # noqa: E501
                    )[0],
                    fill="white",
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M478.598 77.9989C475.068 75.9875 471.089 74.902 467.028 74.8432C462.793 74.7908 458.627 75.9271 455.003 78.1235C451.475 80.3564 448.611 83.4969 446.71 87.217C444.665 91.2063 443.598 95.6259 443.598 100.11C443.598 104.594 444.665 109.014 446.71 113.003C448.611 116.723 451.475 119.863 455.003 122.096C458.624 124.305 462.789 125.456 467.028 125.418C470.916 125.341 474.739 124.405 478.224 122.678C482.132 120.843 485.674 118.31 488.674 115.204L501.985 129.529C497.185 134.55 491.452 138.585 485.108 141.405C478.381 144.575 470.996 146.089 463.566 145.822C456.137 145.555 448.879 143.514 442.397 139.868C435.496 136.032 429.763 130.392 425.81 123.55C421.788 116.5 419.726 108.499 419.839 100.38C419.716 92.4137 421.777 84.5664 425.799 77.6918C429.82 70.8172 435.647 65.1786 442.646 61.3897C449.22 57.8816 456.496 55.8962 463.939 55.58C471.381 55.2637 478.8 56.6248 485.647 59.5628C491.7 62.0958 497.164 65.8564 501.695 70.6078L488.508 86.5527C485.816 83.06 482.445 80.1501 478.598 77.9989V77.9989Z"  # noqa: E501
                    )[0],
                    fill="white",
                ),
                svg.Path(
                    d=convert_path_to_list(
                        "M569.326 76.4645C565.079 74.9119 560.616 74.0294 556.098 73.8485C553.773 73.7249 551.46 74.2572 549.422 75.3849C548.649 75.8603 548.018 76.5352 547.595 77.3388C547.172 78.1423 546.972 79.0451 547.017 79.9524C547.001 80.8546 547.181 81.7495 547.547 82.5744C547.912 83.3993 548.453 84.1342 549.132 84.7276C550.661 86.0871 552.434 87.1438 554.357 87.8418C556.43 88.6307 559.499 89.6688 563.562 90.9145C568.663 92.3241 573.663 94.072 578.532 96.1464C582.534 97.9259 586.027 100.681 588.691 104.16C591.632 108.275 593.094 113.266 592.838 118.32C592.989 123.648 591.37 128.876 588.235 133.185C585.047 137.398 580.735 140.622 575.795 142.486C570.097 144.625 564.05 145.682 557.964 145.6C550.598 145.568 543.292 144.276 536.36 141.78C529.59 139.477 523.295 135.96 517.783 131.399L526.616 113.586C531.24 117.635 536.51 120.877 542.207 123.178C547.251 125.449 552.687 126.719 558.213 126.915C561.004 127.063 563.779 126.415 566.216 125.046C567.153 124.481 567.92 123.674 568.438 122.71C568.956 121.745 569.206 120.659 569.16 119.565C569.177 118.625 568.99 117.692 568.61 116.831C568.23 115.971 567.668 115.204 566.963 114.583C565.369 113.163 563.508 112.076 561.489 111.385C559.291 110.596 556.223 109.683 552.242 108.603C547.198 107.256 542.251 105.563 537.438 103.537C533.514 101.821 530.069 99.1697 527.403 95.8142C524.465 91.8561 522.999 86.9952 523.257 82.0701C523.114 77.0177 524.565 72.0487 527.403 67.8692C530.482 63.6235 534.714 60.352 539.595 58.4435C545.441 56.1441 551.685 55.0291 557.964 55.1631C564.279 55.1553 570.562 56.0501 576.624 57.8206C582.333 59.4215 587.78 61.8411 592.796 65.0041L584.213 83.1912C579.504 80.4246 574.513 78.1696 569.326 76.4645V76.4645Z"  # noqa: E501
                    )[0],
                    fill="white",
                ),
            ],
            # transform and position correctly
            transform=[
                svg.Translate(LOGO_TRANSLATE_X, LOGO_TRANSLATE_Y),
            ],
        ),
    ]

    events = get_events(start, end)
    if start == end:
        elements.extend(create_single_week(events, start))
    else:
        elements.extend(create_multi_week(events, start, end))

    return str(svg.SVG(elements=elements, viewBox=svg.ViewBoxSpec(0, 0, POST_WIDTH, POST_HEIGHT)))
